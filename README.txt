■『プロを目指す人のためのTypeScript入門』サンプルコード

　この圧縮ファイルに収録されている一連のテキストファイルは、書籍『プロを目指す人のためのTypeScript入門』に掲載されているサンプルコードのファイルです。
　圧縮ファイルを解凍すると、項番号（例：1.1.1）またはコラム番号（例：コラム4）に対応するディレクトリ（フォルダ）があり、各ディレクトリにサンプルコードのテキストファイル（.tsファイル）が格納されています。.tsファイルのファイル名の番号は、その項内（またはコラム内）の何番目のサンプルコードかを表しています。たとえば、1.1.3項の2番目に掲載されているサンプルコードは、「1.1.3_静的型付けのメリット (1) 型安全性」ディレクトリの「2.ts」ファイルです。

＜注意事項＞
各サンプルコードは、実際に動作する完全なコードとは限りません。解説のために一部のコードを抜粋したものや、擬似的なコードの場合もあります。ご了承ください。

＜収録ファイル一覧＞

ProTypeScript_SampleCode/
├── 1.1.1_JavaScriptに対する“静的型付け”
│   └── 1.ts
├── 1.1.3_静的型付けのメリット (1) 型安全性
│   ├── 1.ts
│   └── 2.ts
├── 1.1.4_静的型付けのメリット (2) ドキュメント化と入力補完
│   └── 1.ts
├── 1.2.1_TypeScriptコンパイラの役割 (1) 型チェック
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 1.2.2_TypeScriptコンパイラの役割 (2) トランスパイル
│   ├── 1.ts
│   └── 2.ts
├── 1.3.5_初めてのTypeScriptプログラム
│   ├── 1.ts
│   └── 2.ts
├── 2.1.1_文と式の基本
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.1.2_文と式は“結果”の有無で区別する
│   └── 1.ts
├── 2.1.4_式文
│   └── 1.ts
├── 2.2.1_変数宣言の構文
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.2.2_識別子
│   ├── 1.ts
│   └── 2.ts
├── 2.2.3_変数に型註釈を与える
│   ├── 1.ts
│   └── 2.ts
├── 2.2.4_letによる変数宣言と変数への再代入
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.t
├── 2.3.2_TypeScriptにおける数値型の特徴
│   ├── 1.ts
│   └── 2.ts
├── 2.3.3_数値リテラル
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.3.4_任意精度整数（BigInt）
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.3.5_文字列型と3種類の文字列リテラル
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 2.3.6_文字列中のエスケープシーケンス
│   ├── 1.ts
│   └── 2.ts
├── 2.3.7_真偽値と真偽値リテラル
│   └── 1.ts
├── 2.3.8_nullとundefined
│   ├── 1.ts
│   └── 2.ts
├── 2.3.9_プリミティブ型同士の変換 (1) 暗黙の変換を体験する
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.3.10_プリミティブ型同士の変換 (2) 明示的な変換を行う
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── 2.4.1_算術演算子 (1) 二項演算子
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 2.4.2_算術演算子 (2) 単項演算子
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 2.4.3_文字列の結合を+演算子で行う
│   ├── 1.ts
│   └── 2.ts
├── 2.4.4_比較演算子と等価演算子
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 2.4.5_論理演算子 (1) 真偽値の演算
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.4.6_論理演算子 (2) 一般形と短絡評価
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 2.4.7_条件演算子
│   └── 1.ts
├── 2.4.8_代入演算子
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.4.9_その他の演算子
│   └── 1.ts
├── 2.5.1_条件分岐 (1) if文の基本
│   └── 1.ts
├── 2.5.2_ブロック
│   └── 1.ts
├── 2.5.3_条件分岐 (2) elseを使う
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.5.4_switch文
│   └── 1.ts
├── 2.5.5_while文によるループ
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.5.6_for文によるループ
│   ├── 1.ts
│   └── 2.ts
├── 2.6.2_解説
│   ├── 1.ts
│   └── 2.ts
├── 3.1.1_オブジェクトは“連想配列”である
│   └── 1.ts
├── 3.1.2_オブジェクトリテラル (1) 基本的な構文
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.1.3_オブジェクトリテラル (2) プロパティ名の種々の指定方法
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.1.4_プロパティアクセス_ 値の取得と代入
│   ├── 1.ts
│   └── 2.ts
├── 3.1.5_オブジェクトリテラル (3) スプレッド構文
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.1.6_オブジェクトはいつ“同じ”なのか
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 3.2.1_オブジェクト型の記法
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.2.2_オブジェクト型の型チェックと安全性
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.2.3_type文で型に別名を付ける
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.2.4_interface宣言でオブジェクト型を宣言する
│   └── 1.ts
├── 3.2.5_任意のプロパティ名を許容する型（インデックスシグネチャ）
│   └── 1.ts
├── 3.2.6_オプショナルなプロパティの宣言
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.2.7_読み取り専用プロパティの宣言
│   └── 1.ts
├── 3.2.8_typeofキーワードで変数の型を得る
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.3.1_部分型とは
│   └── 1.ts
├── 3.3.2_プロパティの包含関係による部分型関係の発生
│   ├── 1.ts
│   └── 2.ts
├── 3.3.3_余剰プロパティに対する型エラーについて
│   ├── 1.ts
│   └── 2.ts
├── 3.4.1_型引数を持つ型を宣言する
│   ├── 1.ts
│   └── 2.ts
├── 3.4.2_型引数を持つ型を使用する
│   ├── 1.ts
│   └── 2.ts
├── 3.4.3_部分型関係による型引数の制約
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.4.4_オプショナルな型引数
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.5.1_配列リテラルで配列を作成する
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.5.2_配列の要素にアクセスする
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.5.3_配列型の記法
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.5.4_readonly配列型
│   └── 1.ts
├── 3.5.5_配列の機能を使う
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.5.6_for-of文によるループ
│   ├── 1.ts
│   └── 2.ts
├── 3.5.7_タプル型
│   ├── 1.ts
│   └── 2.ts
├── 3.6.1_オブジェクトの分割代入 (1) 基本的なパターン
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.6.2_オブジェクトの分割代入 (2) ネストしたパターン
│   ├── 1.ts
│   └── 2.ts
├── 3.6.3_配列の分割代入
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── 3.6.4_分割代入のデフォルト値
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 3.6.5_restパターンでオブジェクトの残りを取得する
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.7.1_Dateオブジェクト
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.7.2_正規表現オブジェクト (1) 正規表現の基本
│   ├── 1.ts
│   └── 2.ts
├── 3.7.3_正規表現オブジェクト (2) 正規表現を使う方法
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.7.4_Mapオブジェクト・Setオブジェクト
│   └── 1.ts
├── 3.7.5_プリミティブなのにプロパティがある？
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.8.1_データ処理をしよう
│   └── 1.ts
├── 3.8.2_解説
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.8.3_別解
│   └── 1.ts
├── 4.1.1_関数宣言で関数を作る
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.1.2_返り値が無い関数を作る
│   ├── 1.ts
│   └── 2.ts
├── 4.1.3_関数式で関数を作る
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.1.4_アロー関数式で関数を作る
│   └── 1.ts
├── 4.1.5_アロー関数式の省略形
│   ├── 1.ts
│   └── 2.ts
├── 4.1.6_メソッド記法で関数を作る
│   └── 1.ts
├── 4.1.7_可変長引数の宣言
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.1.8_関数呼び出しにおけるスプレッド構文
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.1.9_オプショナル引数の宣言
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.1.10_コールバック関数を使ってみる
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.2.1_関数型の記法
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.2.2_返り値の型註釈は省略可能
│   ├── 1.ts
│   └── 2.ts
├── 4.2.3_返り値の型註釈は省略すべきか
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.2.4_引数の型註釈が省略可能な場合
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── 4.2.5_コールシグネチャによる関数型の表現
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.3.1_返り値の型による部分型関係
│   ├── 1.ts
│   └── 2.ts
├── 4.3.2_引数の型による部分型関係
│   └── 1.ts
├── 4.3.3_引数の数による部分型関係
│   └── 1.ts
├── 4.4.1_関数の型引数とは
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.4.2_関数の型引数を宣言する方法
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 4.4.3_関数の型引数は省略できる
│   ├── 1.ts
│   └── 2.ts
├── 4.4.4_型引数を持つ関数型
│   ├── 1.ts
│   └── 2.ts
├── 4.4_ジェネリクス
│   └── 1.ts
├── 4.5.1_変数のスコープとは
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.5.2_ブロックスコープと関数スコープ
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.6.1_簡単な関数を書いてみよう
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.6.2_解説
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.6.3_コールバック関数の練習
│   ├── 1.ts
│   └── 2.ts
├── 4.6.4_解説
│   ├── 1.ts
│   └── 2.ts
├── 5.1.1_クラス宣言とnew構文
│   ├── 1.ts
│   └── 2.ts
├── 5.1.2_プロパティを宣言する
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 5.1.3_メソッドを宣言する
│   ├── 1.ts
│   └── 2.ts
├── 5.1.4_コンストラクタ
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 5.1.5_静的プロパティ・メソッド
│   └── 1.ts
├── 5.1.6_3種類のアクセシビリティ修飾子
│   └── 1.ts
├── 5.1.7_コンストラクタ引数でのプロパティ宣言
│   ├── 1.ts
│   └── 2.ts
├── 5.1.8_クラス式でクラスを作成する
│   └── 1.ts
├── 5.1.9_もう1つのプライベートプロパティ
│   └── 1.ts
├── 5.1.10_クラスの静的初期化ブロック
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 5.1.11_型引数を持つクラス
│   └── 1.ts
├── 5.2.1_クラス宣言はインスタンスの型を作る
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 5.2.2_newシグネチャによるインスタンス化可能性の表現
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 5.2.3_instanceof演算子と型の絞り込み
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 5.3.1_継承 (1) 子は親の機能を受け継ぐ
│   ├── 1.ts
│   └── 2.ts
├── 5.3.2_継承 (2) 親の機能を上書きする
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 5.3.3_override修飾子とその威力
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 5.3.4_privateとprotectedの動作と使い所
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 5.3.5_implementsキーワードによるクラスの型チェック
│   ├── 1.ts
│   └── 2.ts
├── 5.4.1_関数の中のthisは呼び出し方によって決まる
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 5.4.2_アロー関数におけるthis
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 5.4.3_thisを操作するメソッド
│   ├── 1.ts
│   └── 2.ts
├── 5.4.4_関数の中以外のthis
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 5.5.1_throw文とErrorオブジェクト
│   ├── 1.ts
│   └── 2.ts
├── 5.5.2_例外をキャッチするtry-catch文
│   ├── 1.ts
│   └── 2.ts
├── 5.5.3_例外処理と大域脱出
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 5.5.4_finallyで脱出に割り込む
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 5.6.1_クラスに書き換えてみる
│   ├── 1.ts
│   └── 2.ts
├── 5.6.2_解説
│   ├── 1.ts
│   └── 2.ts
├── 5.6.3_クラスを関数に書き換えてみる
│   └── 1.ts
├── 5.6.4_解説
│   └── 1.ts
├── 6.1.1_ユニオン型の基本
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.1.2_伝播するユニオン型
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.1.3_インターセクション型とは
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.1.4_ユニオン型とインターセクション型の表裏一体な関係
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.1.5_オプショナルプロパティ再訪
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.1.6_オプショナルチェイニングによるプロパティアクセス
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 6.2.1_4種類のリテラル型
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.2.2_テンプレートリテラル型
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.2.3_ユニオン型とリテラル型を組み合わせて使うケース
│   ├── 1.ts
│   └── 2.ts
├── 6.2.4_リテラル型のwidening
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   ├── 6.ts
│   ├── 7.ts
│   └── 8.ts
├── 6.2.5_wideningされるリテラル型・wideningされないリテラル型
│   └── 1.ts
├── 6.3.1_等価演算子を用いる絞り込み
│   ├── 1.ts
│   └── 2.ts
├── 6.3.2_typeof演算子を用いる絞り込み
│   ├── 1.ts
│   └── 2.ts
├── 6.3.3_代数的データ型をユニオン型で再現するテクニック
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.3.4_switch文でも型を絞り込める
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.4.1_lookup型とは
│   ├── 1.ts
│   └── 2.ts
├── 6.4.2_keyof型とは
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 6.4.3_keyof型・lookup型とジェネリクス
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.4.4_number型もキーになれる？
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.5.1_型アサーションを用いて式の型をごまかす
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.5.2_as constの用法
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.6.1_any型という最終兵器
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.6.3_anyに近いが安全なunknown型
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.7.1_object型・never型
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.7.2_型述語（ユーザー定義型ガード）
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── 6.7.3_可変長タプル型
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.7.4_mapped types
│   ├── 1.ts
│   └── 2.ts
├── 6.7.5_conditional types
│   └── 1.ts
├── 6.7.6_組み込みの型を使いこなす
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 6.8.2_解説
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.8.3_タグ付きユニオンの練習 (2)
│   └── 1.ts
├── 6.8.4_解説
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.8.5_タグ付きユニオンの練習 (3)
│   └── 1.ts
├── 6.8.6_解説
│   └── 1.ts
├── 7.1.1_変数のエクスポートとインポート
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   ├── 6.ts
│   ├── 7.ts
│   └── 8.ts
├── 7.1.2_関数もエクスポートできる
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 7.1.3_defaultエクスポートとdefaultインポート
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   ├── 6.ts
│   ├── 7.ts
│   └── 8.ts
├── 7.1.4_型のインポート・エクスポート
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   ├── 6.ts
│   ├── 7.ts
│   ├── 8.ts
│   ├── 9.ts
│   ├── 10.ts
│   └── 11.ts
├── 7.1.5_その他の関連構文
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 7.2.1_Node.jsの組み込みモジュール
│   └── 1.ts
├── 7.2.2_npmとは
│   └── 1.ts
├── 7.3.1_@typesパッケージのインストール
│   └── 1.ts
├── 7.4.1_ファイルを読み込んでみる
│   └── 1.txt
├── 7.4.2_解説
│   └── 1.ts
├── 7.4.3_pathモジュールも使ってみる
│   └── 1.ts
├── 7.4.4_解説
│   └── 1.ts
├── 8.1.2_シングルスレッドモデル・ノンブロッキング
│   └── 1.ts
├── 8.2.1_コールバック関数とは
│   ├── 1.ts
│   └── 2.ts
├── 8.2.2_タイマーの例
│   └── 1.ts
├── 8.2.3_fsモジュールによるファイル操作の例
│   ├── 1.ts
│   └── 2.ts
├── 8.2.4_同期処理と非同期処理の順序
│   ├── 1.ts
│   └── 2.ts
├── 8.3.1_Promise版のfsを使ってみる
│   └── 1.ts
├── 8.3.2_コールバック関数の登録とエラー処理 (1)
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 8.3.3_コールバック関数の登録とエラー処理 (2)
│   └── 1.ts
├── 8.3.4_自分でPromiseオブジェクトを作る
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 8.3.5_Promiseの静的メソッド (1)
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 8.3.6_Promiseの静的メソッド (2)
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 8.3.7_Promiseの静的メソッド (3)
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 8.3.8_Promiseチェーン (1) チェーンを作る
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 8.3.9_Promiseチェーン (2) 非同期処理の連鎖
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 8.3.10_Promiseチェーン (3) エラーの扱い
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   ├── 6.ts
│   └── 7.ts
├── 8.3.11_dynamic import構文
│   └── 1.ts
├── 8.4.1_async関数を作ってみる
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 8.4.2_await式も使ってみる
│   ├── 1.ts
│   └── 2.ts
├── 8.4.3_awaitの返り値
│   ├── 1.ts
│   └── 2.ts
├── 8.4.4_awaitとエラー処理
│   └── 1.ts
├── 8.4.5_async関数のいろいろな宣言方法
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 8.5.1_fs_promisesを使ってみる
│   └── 1.ts
├── 8.5.2_解説
│   └── 1.ts
├── 8.5.4_解説
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 9.2.2_strictNullChecksでnullとundefinedを安全に検査する
│   ├── 1.ts
│   └── 2.ts
├── 9.2.3_型の書き忘れや推論の失敗を防ぐnoImplicitAnyオプション
│   ├── 1.ts
│   └── 2.ts
├── 9.2.4_インデックスアクセスを厳しくするnoUncheckedIndexedAccessオプション
│   ├── 1.ts
│   └── 2.ts
├── コラム4_TypeScriptにおける数値はIEEE 754倍精度浮動小数点数である
│   ├── 1.ts
│   └── 2.ts
├── コラム6_論理代入演算子の特殊な挙動
│   └── 1.ts
├── コラム7_セミコロンは省略できる
│   └── 1.ts
├── コラム8_オブジェクトのプロパティとconst
│   └── 1.ts
├── コラム9_インデックスシグネチャに潜む罠
│   ├── 1.ts
│   └── 2.ts
├── コラム10_typeofはいつ使うべきか
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── コラム13_配列の要素にアクセスするときの密かな危険性
│   └── 1.ts
├── コラム14_return文とセミコロン省略の罠
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── コラム15_関数もオブジェクトの一種である
│   ├── 1.ts
│   └── 2.ts
├── コラム17_メソッド記法と部分型関係
│   └── 1.ts
├── コラム18_読み取り専用プロパティの部分型について
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── コラム19_型引数はどのように推論されるのか
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── コラム20_varによる変数の宣言
│   └── 1.ts
├── コラム21_クラスも変数である
│   └── 1.ts
├── コラム22_変数名の名前空間と型名の名前空間
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── コラム23_継承で明らかになるprivateと#の差異
│   └── 1.ts
├── コラム24_組み込みオブジェクトとクラスーー配列の継承を例にーー
│   ├── 1.ts
│   └── 2.ts
├── コラム25_throwは何でも投げられる
│   ├── 1.ts
│   └── 2.ts
├── コラム26_2種類の「ない」：存在しないかもしれないプロパティを取得できない理由
│   ├── 1.ts
│   └── 2.ts
├── コラム28_型アサーションの古い記法
│   └── 1.ts
├── コラム29_!を用いてnullとundefinedを無視する
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── コラム30_anyをisで書き換えてみる
│   ├── 1.ts
│   └── 2.ts
├── コラム31_モジュールとカプセル化
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── コラム32_モジュールの実体は1つ
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── コラム34_スクリプトとモジュール
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── コラム36_CommonJSモジュールとは
│   ├── 1.ts
│   └── 2.ts
├── コラム37_自分で型定義ファイルを作るには
│   └── 1.ts
├── コラム38_top-level await
│   ├── 1.ts
│   └── 2.ts
└── README.txt

以　上